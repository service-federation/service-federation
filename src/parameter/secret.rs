use crate::config::Config;
use crate::error::{Error, Result};
use std::collections::HashMap;
use std::path::{Path, PathBuf};

/// Analysis of secret parameters in a config.
pub struct SecretAnalysis {
    /// Secret parameter names that need auto-generated values.
    pub needs_generation: Vec<String>,
    /// Manual secrets missing from .env: (name, description).
    pub missing_manual: Vec<(String, Option<String>)>,
    /// Path to the .env file that holds (or will hold) secrets.
    pub env_path: PathBuf,
    /// Whether the .env file is gitignored.
    pub is_gitignored: bool,
    /// Whether we're inside a git repository at all.
    pub in_git_repo: bool,
    /// Existing values already loaded from .env.
    pub existing_values: HashMap<String, String>,
}

/// Check if a path is gitignored in the enclosing repository.
///
/// Returns `(in_git_repo, is_ignored)`.
pub fn is_gitignored(work_dir: &Path, relative_path: &str) -> (bool, bool) {
    match git2::Repository::discover(work_dir) {
        Ok(repo) => {
            let ignored = repo.is_path_ignored(relative_path).unwrap_or(false);
            (true, ignored)
        }
        Err(_) => (false, false),
    }
}

/// Scan config for secret parameters and classify what's present vs. missing.
///
/// `secrets_file` is the absolute path to the file where generated secrets are stored.
///
/// Returns `None` if no secret parameters exist.
pub fn analyze_secrets(config: &Config, work_dir: &Path, secrets_file: &Path) -> Result<Option<SecretAnalysis>> {
    let effective_params = config.get_effective_parameters();

    // Collect all secret parameters
    let secret_params: Vec<(&String, &crate::config::Parameter)> = effective_params
        .iter()
        .filter(|(_, p)| p.is_secret_type())
        .collect();

    if secret_params.is_empty() {
        return Ok(None);
    }

    let env_path = secrets_file.to_path_buf();

    // Load existing values from the secrets file and all configured env_files
    let mut existing_values = load_existing_env(&env_path);
    for env_file in &config.env_file {
        let ef_path = work_dir.join(env_file);
        for (k, v) in load_existing_env(&ef_path) {
            existing_values.entry(k).or_insert(v);
        }
    }

    // Compute relative path for gitignore check
    let relative_path = secrets_file
        .strip_prefix(work_dir)
        .map(|p| p.to_string_lossy().to_string())
        .unwrap_or_else(|_| secrets_file.to_string_lossy().to_string());
    let (in_git_repo, is_gitignored) = is_gitignored(work_dir, &relative_path);

    let mut needs_generation = Vec::new();
    let mut missing_manual = Vec::new();

    for (name, param) in &secret_params {
        // Already resolved (from .env or explicit value)?
        if param.value.is_some() || existing_values.contains_key(name.as_str()) {
            continue;
        }

        if param.is_manual_secret() {
            missing_manual.push(((*name).clone(), param.description.clone()));
        } else {
            needs_generation.push((*name).clone());
        }
    }

    Ok(Some(SecretAnalysis {
        needs_generation,
        missing_manual,
        env_path,
        is_gitignored,
        in_git_repo,
        existing_values,
    }))
}

/// Generate a cryptographically-reasonable random secret string.
///
/// 32-char alphanumeric — enough entropy for dev/local use.
pub fn generate_secret() -> String {
    use rand::Rng;
    const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let mut rng = rand::thread_rng();
    (0..32)
        .map(|_| {
            let idx = rng.gen_range(0..CHARSET.len());
            CHARSET[idx] as char
        })
        .collect()
}

/// Append generated secret values to an .env file.
///
/// Creates the file with a header comment if it doesn't exist.
/// Only appends new keys — never overwrites existing values.
pub fn write_env_file(path: &Path, generated_values: &[(String, String)]) -> Result<()> {
    use std::io::Write;

    let exists = path.exists();
    let mut file = std::fs::OpenOptions::new()
        .create(true)
        .append(true)
        .open(path)
        .map_err(|e| Error::Filesystem(format!("Cannot write '{}': {}", path.display(), e)))?;

    if !exists {
        writeln!(file, "# Auto-generated by fed — do not commit this file")
            .map_err(|e| Error::Filesystem(format!("Write error: {}", e)))?;
    }

    for (key, value) in generated_values {
        writeln!(file, "{}={}", key, value)
            .map_err(|e| Error::Filesystem(format!("Write error: {}", e)))?;
    }

    Ok(())
}

/// Load key-value pairs from an existing .env file, if it exists.
fn load_existing_env(path: &Path) -> HashMap<String, String> {
    if !path.exists() {
        return HashMap::new();
    }

    // Use dotenvy's iterator to parse the file
    match dotenvy::from_path_iter(path) {
        Ok(iter) => iter.filter_map(|r| r.ok()).collect(),
        Err(_) => HashMap::new(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // ========================================================================
    // generate_secret
    // ========================================================================

    #[test]
    fn generate_secret_length() {
        let secret = generate_secret();
        assert_eq!(secret.len(), 32);
    }

    #[test]
    fn generate_secret_alphanumeric() {
        let secret = generate_secret();
        assert!(
            secret.chars().all(|c| c.is_ascii_alphanumeric()),
            "Secret should be alphanumeric, got: {}",
            secret
        );
    }

    #[test]
    fn generate_secret_uniqueness() {
        let a = generate_secret();
        let b = generate_secret();
        assert_ne!(a, b, "Two generated secrets should differ");
    }

    // ========================================================================
    // write_env_file
    // ========================================================================

    #[test]
    fn write_env_creates_file_with_header() {
        let dir = tempfile::tempdir().unwrap();
        let env_path = dir.path().join(".env");

        write_env_file(
            &env_path,
            &[("SECRET_KEY".to_string(), "abc123".to_string())],
        )
        .unwrap();

        let content = std::fs::read_to_string(&env_path).unwrap();
        assert!(content.contains("# Auto-generated by fed"));
        assert!(content.contains("SECRET_KEY=abc123"));
    }

    #[test]
    fn write_env_appends_to_existing() {
        let dir = tempfile::tempdir().unwrap();
        let env_path = dir.path().join(".env");
        std::fs::write(&env_path, "EXISTING=value\n").unwrap();

        write_env_file(
            &env_path,
            &[("NEW_KEY".to_string(), "new_value".to_string())],
        )
        .unwrap();

        let content = std::fs::read_to_string(&env_path).unwrap();
        assert!(content.starts_with("EXISTING=value"));
        assert!(content.contains("NEW_KEY=new_value"));
        // Should NOT have the header since file already existed
        assert!(!content.contains("Auto-generated"));
    }

    // ========================================================================
    // is_gitignored
    // ========================================================================

    #[test]
    fn is_gitignored_outside_repo() {
        let dir = tempfile::tempdir().unwrap();
        let (in_repo, ignored) = is_gitignored(dir.path(), ".env");
        assert!(!in_repo);
        assert!(!ignored);
    }

    #[test]
    fn is_gitignored_not_ignored_in_repo() {
        let dir = tempfile::tempdir().unwrap();
        // Initialize a git repo without a .gitignore
        git2::Repository::init(dir.path()).unwrap();

        let (in_repo, ignored) = is_gitignored(dir.path(), ".env");
        assert!(in_repo);
        assert!(!ignored);
    }

    #[test]
    fn is_gitignored_ignored_in_repo() {
        let dir = tempfile::tempdir().unwrap();
        git2::Repository::init(dir.path()).unwrap();
        std::fs::write(dir.path().join(".gitignore"), ".env\n").unwrap();

        let (in_repo, ignored) = is_gitignored(dir.path(), ".env");
        assert!(in_repo);
        assert!(ignored);
    }

    // ========================================================================
    // analyze_secrets
    // ========================================================================

    #[test]
    fn analyze_no_secrets_returns_none() {
        let config = Config::default();
        let dir = tempfile::tempdir().unwrap();
        let secrets_file = dir.path().join(".env.secrets");
        let result = analyze_secrets(&config, dir.path(), &secrets_file).unwrap();
        assert!(result.is_none());
    }

    #[test]
    fn analyze_classifies_generated_and_manual() {
        let dir = tempfile::tempdir().unwrap();

        let mut config = Config::default();
        config.parameters.insert(
            "SESSION_KEY".to_string(),
            crate::config::Parameter {
                param_type: Some("secret".to_string()),
                ..Default::default()
            },
        );
        config.parameters.insert(
            "GITHUB_SECRET".to_string(),
            crate::config::Parameter {
                param_type: Some("secret".to_string()),
                source: Some("manual".to_string()),
                description: Some("GitHub OAuth secret".to_string()),
                ..Default::default()
            },
        );

        let secrets_file = dir.path().join(".env.secrets");
        let analysis = analyze_secrets(&config, dir.path(), &secrets_file).unwrap().unwrap();
        assert_eq!(analysis.needs_generation, vec!["SESSION_KEY".to_string()]);
        assert_eq!(analysis.missing_manual.len(), 1);
        assert_eq!(analysis.missing_manual[0].0, "GITHUB_SECRET");
        assert_eq!(
            analysis.missing_manual[0].1.as_deref(),
            Some("GitHub OAuth secret")
        );
    }

    #[test]
    fn analyze_skips_secrets_with_existing_env_values() {
        let dir = tempfile::tempdir().unwrap();
        let secrets_file = dir.path().join(".env.secrets");
        std::fs::write(
            &secrets_file,
            "SESSION_KEY=already_set\n",
        )
        .unwrap();

        let mut config = Config::default();
        config.parameters.insert(
            "SESSION_KEY".to_string(),
            crate::config::Parameter {
                param_type: Some("secret".to_string()),
                ..Default::default()
            },
        );

        let analysis = analyze_secrets(&config, dir.path(), &secrets_file).unwrap().unwrap();
        assert!(
            analysis.needs_generation.is_empty(),
            "Should not need to generate an already-present secret"
        );
    }
}
